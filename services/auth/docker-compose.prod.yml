# # RUN line below for prod in local machine # #
# # # docker compose -p mynute-auth-prod -f ./auth/docker-compose.prod.yml up -d --build --remove-orphans

# # ADD line below for prod in VPS using Dokploy at Advanced > Run Command # #
# compose build --no-cache && docker compose up -d --force-recreate

services:
  postgres:
    image: postgres:17.5
    restart: always
    volumes:
      - ./postgres-data:/var/lib/postgresql/data
    env_file:
      - .env
    environment:
      - POSTGRES_HOST=postgres
      - APP_ENV=${APP_ENV:-prod}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_DB_PROD=${POSTGRES_DB_PROD}
      - POSTGRES_DB_TEST=${POSTGRES_DB_TEST}
      - POSTGRES_DB_DEV=${POSTGRES_DB_DEV}
    healthcheck:
      test: ["CMD-SHELL", "case $APP_ENV in prod) DB_NAME=$POSTGRES_DB_PROD ;; test) DB_NAME=$POSTGRES_DB_TEST ;; dev) DB_NAME=$POSTGRES_DB_DEV ;; *) echo 'Invalid APP_ENV'; exit 1 ;; esac; pg_isready -U ${POSTGRES_USER:-postgres} -d $DB_NAME"]
      interval: 300s
      timeout: 5s
      retries: 10
      start_period: 15s
    command: >
      bash -c "
        echo '‚úÖ   Starting PostgreSQL...';
        docker-entrypoint.sh postgres &

        # Wait for PostgreSQL to be fully ready
        echo '‚è≥   Waiting for PostgreSQL to start...';
        until pg_isready -h 127.0.0.1 -p 5432 -U $POSTGRES_USER; do
          echo '‚è≥   Still waiting for PostgreSQL...';
          sleep 2;
        done;

        echo '‚úÖ   PostgreSQL is ready! Proceeding with initialization...';

        # Determine the database name based on APP_ENV
        case $APP_ENV in
          prod)
            DB_NAME=$POSTGRES_DB_PROD
            ;;
          test)
            DB_NAME=$POSTGRES_DB_TEST
            ;;
          dev)
            DB_NAME=$POSTGRES_DB_DEV
            ;;
          *)
            echo '‚ùå   APP_ENV must be one of prod, test, or dev';
            exit 1
            ;;
        esac

        # Ensure DB_NAME is not empty
        if [ -z \"\$DB_NAME\" ]; then
          echo '‚ùå   ERROR: DB_NAME is not set. Please check your .env file.';
          echo \"‚ùå   Required: POSTGRES_DB_PROD, POSTGRES_DB_TEST, or POSTGRES_DB_DEV based on APP_ENV=\$APP_ENV\";
          exit 1
        fi

        # Ensure the main database exists
        echo \"Checking if main database '\$DB_NAME' exists...\";
        DB_EXISTS=\$(psql -U \"$POSTGRES_USER\" -d postgres -tAc \\\"SELECT 1 FROM pg_database WHERE datname='\$DB_NAME'\\\" || echo \"0\");
        if echo \"\$DB_EXISTS\" | grep -q \"1\"; then
          echo \"‚úÖ   Main database '\$DB_NAME' already exists.\";
        else
          echo \"üöÄ   Creating main database: '\$DB_NAME'\";
          psql -U \"$POSTGRES_USER\" -d postgres -c \"CREATE DATABASE \$DB_NAME;\";
        fi;

        echo 'üéâ   Database initialization complete!';

        # Keep PostgreSQL running in the foreground to prevent container exit
        wait
      "
    networks:
      - mynute-auth-network

  go-auth-app:
    build: 
      context: ..
      dockerfile: ./auth/Dockerfile
    restart: always
    env_file:
      - .env
    ports:
      - "${AUTH_SERVICE_PORT:-4001}:${AUTH_SERVICE_PORT:-4001}"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - mynute-auth-network
   
networks:
  mynute-auth-network:

volumes:
  postgres-data:
